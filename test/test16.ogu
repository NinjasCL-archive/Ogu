; traits

trait Figura self where

   def area : self -> Float

   def perimetro : self -> Float

class Circulo(x,y:Int, radio:Int)

class Rectangulo(x,y:Int,ancho,alto:Int) 

instance Figura Circulo where

 let area circ = pi * (radio circ) ^ 2

 let perimetro circ = 2 * pi * (radio circ)
 

instance Figura Rectangulo where

   let area rect = (ancho rect)  * (alto rect)

   let perimetro rect = 2 * (ancho rect + alto rect)

;; es syntactic sugar para type Circulo = Circulo{x:Int,y:Int,r:Int}
class Circulo(x,y,r:Int)

class Rectangulo(x,y,w,h:Int)

class Cuadrado(x,y,l:Int) = Rectangulo(x,y,l,l)

class Triangulo(x1,y1,x2,y2,x3,y3:Int)


data Figura = Circulo | Rectangulo | Cuadrado | Triangulo

class Leaf(value:Int)

data Tree = Empty | Leaf | Node(Tree,Tree)

def depth : Tree -> Int

let depth Empty = 0
 
let depth Leaf = 1
 
let depth Node(l,r) = 1 + max (depth l) (depth r)

data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)

let empty = Empty
let l1 = Cons 5 Empty


;; clases mutables
mut class Auto(marca:String, años:Int, kilometraje:Int)

def avanzar! : Auto -> Int -> ()   ;; una función que realizará una mutación sobre su argumento o el entorno debe llevar !

let avanzar! auto km =
    set kilometraje auto = (kilometraje auto) + km


;; las clases pue

var auto = Auto("ford", 5, 50000) ;; syntactic sugar para Auto{marca="ford", años=5, kilometraje=50000)

;; por supuesto se puede hacer

avanzar! auto 10



