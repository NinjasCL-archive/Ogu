;; types

enum Boolean = false | true

data Bool' = False | True

data BasicColor = Red | Green | Blue

type String = [Char]

type IntVector = (Int,Int)

type StrMap v = {String -> v}

var edades : StrMap Int = {"Juan"->10, "Pedro" -> 11, "María" -> 12}
var edades' : (StrMap Int) = {"Juan"->10, "Pedro" -> 11, "María" -> 12}

data Auto = Auto{companía:String, modelo:String, año:Int} ; structs

data Vehicle = Car{company:String, model:String, year:Int} ; structs
             | Bus{company:String, model:String, year:Int, capacity: Int}
             deriving (Show)

let b : Bool = False
let color : BasicColor = Red
let s : String = ""
let iv = (10,10)
let edades : StrMap Int = {"Pedro"->25, "Juan"->30, "Diego"->40}

let mustang56 = Car{company="Ford", model="Mustang", year=1956}

let comp = company mustang56

let mdl = model mustang56

let yr = year mustang56

data Stk x = Stk x deriving (Show)

type Stack a = Stk [a]

let create              = Stk []
let push x (Stk xs)     = Stk (x::xs)
let pop    (Stk (x::xs)) = Stk xs
let top    (Stk (x::xs)) = x
let empty? (Stk xs)     = null xs

let stack = create

let stack1 = push 1 stack

let uno = top stack1

let stack2 = pop stack1

if empty? stack2 then println! "stack2 está vacío" else println "WTF??"

trait Ord x where
    def succ : x -> x

    def prev : x -> x

instance Ord BasicColor where 

    let succ x
        | x == Red = Green
        | x == Green = Blue
        | x == Blue = Red

    let prev x
        | x == Red = Blue
        | x == Green = Red
        | x == Blue = Green

let r = Red
let g = succ r


trait Eq a where 

    def == : a -> a -> Bool

    def /= : a -> a -> Bool
    
    let a /= b = not (a == b)


instance Eq Int where
    
    let == x y = (x-y) == 0
    
 