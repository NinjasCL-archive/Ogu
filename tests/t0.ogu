def f : (x : Int) = x

def A : class (x,y:Int) = {}

def Complex : class (x,y:Real)  

def Complex (x:Real) = Complex(x, 0)

def Complex = {
	
}

def Cavernicola : class (nombre, grito : String)
	
def Cavernicola  (nombre:String) = Cavernicola(nombre,grito)

def Cavernicola = {

	def pelear  () = {
		println "yiko pelea!"
		gritar()
	}

	def gritar () = {
		println grito
	}

}


def evento : Ventana, String -> Void

def Ventana : class = {
	
	var OnShow : evento =  alert

	def show  () = {
		//....
		onShow (this, "show!")
	}

	def alert  (msg:String) = {
		println "alerta "+msg
	}
}

doc "funcion recursiva"
author "eduardo diaz"
version 1
see (fact0)
def factorial : Int -> Int
def factorial 0 = 1
def factorial n = n * factorial (n-1)

def fact(n:Int) -> Int = 
	if (n == 0)
	   1
	else
	   n = n * fact(n-1)

def f : (n:Int) -> Int = 
	if (n == 0)
	   1
	else
	   n = n * fact(n-1)

var pf = fact

pf (4)

pf = factorial

pf (5) // <- parser try this as a annotation, semantic analysis should handle  this

var pf2 : Int->Int

pf2 = factorial

pf2 = fact


val pf3 :  factorial


pf3 (0) // <- this is an error, catch it with semantic analysis

val pf4 = factorial // es lo mismo que val pf4 : factorial = factorial


